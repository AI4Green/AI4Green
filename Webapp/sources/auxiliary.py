#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This module contains auxiliary variables and functions used throughout the app
"""
import os.path  # module for pathname manipulates
from typing import Dict, List, Optional, Tuple, Type, Union

from flask import abort, request
from flask_login import current_user
from psmiles import PolymerSmiles
from sources import models
from sources.extensions import db

"""This defines absolute paths to databases"""
BASE_DIR = os.path.dirname(
    os.path.abspath(__file__)
)  # absolute path to the directory containing this file


def replace_symbols(
    compound: str,
) -> str:  # restores the initial smiles string with the sharp, plus and minus symbols
    compound = compound.replace("sharp", "%23")
    compound = compound.replace("plus", "%2B")
    return compound.replace("minus", "%2D")


def code_symbols(
    compound: str,
) -> str:  # converts the sharp, plus, and minus symbols into the URL encoding format
    compound = compound.replace("#", "%23")
    compound = compound.replace("+", "%2B")
    return compound.replace("-", "%2D")


def smiles_symbols(
    compound: str,
) -> (
    str
):  # restores the sharp plus and minus symbols from the string generated by marvinJS
    return compound.replace("minus", "-").replace("plus", "+").replace("sharp", "#")


def extract_inside_brackets(
    s: str,
    start_index: int,
) -> str:
    """
    Extracts contents of brackets to identify branching in polymer SMILES.
    Handles nested branching.

    Args:
        s - whole SMILES string
        start_index - index of first bracket

    Returns:
        The branch SMILES string and end index, or -1 if no branch found
    """
    balance = 0
    inner_content = ""
    for i in range(start_index, len(s)):
        if s[i] == "(":
            balance += 1
        elif s[i] == ")":
            balance -= 1

        inner_content += s[i]  # Capture the character

        if balance == 0:  # Found matching closing parenthesis
            return inner_content, i

    return inner_content, -1  # Return -1 if no matching parenthesis found


def is_within_brackets(expression, target="{+n}"):
    """
    Checks if a target substring (like "{+n}") is within brackets.

    Args:
    - expression (str): String to search.
    - target (str): The substring to check if it's within brackets.

    Returns:
    - bool: True if the target substring is within brackets, False otherwise.
    """
    # Find the position of the target in the expression
    target_index = expression.find(target)

    # Track the context of parentheses up to the target's position
    balance = 0
    for i in range(target_index):
        if expression[i] == "(":
            balance += 1
        elif expression[i] == ")":
            balance -= 1

    # If we have open parentheses when reaching the target, it is within brackets
    return balance > 0


def get_last_bracketed_expression(expression):
    """
    Returns the last set of brackets, including its content, in a given expression.

    Args:
    - expression (str): The input string containing brackets.

    Returns:
    - str: The last complete set of brackets and its content, or an empty string if none found.
    """
    # Initialize variables to store positions of the last matching brackets
    open_index = -1
    close_index = -1
    balance = 0

    # Traverse the expression in reverse to find the last matching pair of brackets
    for i in range(len(expression) - 1, -1, -1):
        if expression[i] == ")":
            if balance == 0:
                close_index = i
            balance += 1
        elif expression[i] == "(":
            balance -= 1
            if balance == 0:
                open_index = i
                break

    # If we have found a matching set, return the substring
    if open_index != -1 and close_index != -1:
        return expression[open_index + 1 : close_index]
    return ""


def reformat_smiles(smiles):
    branch = smiles.split(")")[-1]
    smiles = smiles[: smiles.rfind(branch)]
    inner = get_last_bracketed_expression(smiles)
    smiles = smiles.split(inner)[0] + branch + ")" + inner

    return smiles


def find_polymer_repeat_unit(
    compound: str,
) -> str:
    """
    Identify the repeat group within a polymer SMILES string.
    Must be done before smiles is cleaned.
    Uses {-} and {+n} to find repeat unit.
    """
    start_marker = compound.find("{-}")
    end_marker = compound.find("{+n}")

    # If both {-} and {+} are found
    if start_marker != -1 and end_marker != -1:
        # Reformat if end of SRU is treated as a branch. e.g. *C{-}(CC{+n}*)C where {+n} is within brackets
        if is_within_brackets(compound, "{+n}"):
            compound = reformat_smiles(compound)
            start_marker = compound.find("{-}")
            end_marker = compound.find("{+n}")

        # Start is the character just before {-}, and end is the character just before {+}
        result = compound[start_marker - 1] + compound[start_marker + 3 : end_marker]

        # Check for branching: if the character after {+} is '('
        if end_marker + 4 < len(compound) and compound[end_marker + 4] == "(":
            branch, close_paren = extract_inside_brackets(compound, end_marker + 4)
            if close_paren != -1:
                result += branch

            # check for more branching
            while close_paren + 1 < len(compound) and compound[close_paren + 1] == "(":
                branch, close_paren = extract_inside_brackets(compound, close_paren + 1)
                if close_paren != -1:
                    result += branch
        return result
    # if either {-} or {+} is not found
    return ""


def clean_polymer_smiles(
    compound: str,
) -> str:
    """
    Removes polymer symbols from the string generated by sketchers. last one removes dangling bonds
    """
    return compound.replace("{+n}", "").replace("{-}", "").replace("-", "")


def canonicalise(smiles):
    """
    Canonicalise a polymer SMILES string. Not for use when endgroups are known (must have two '*'s)
    """
    ps = PolymerSmiles(smiles)
    smiles = ps.canonicalize
    return str(smiles).replace("[", "").replace("]", "")


def get_data(field: str, request_data: Optional[Dict] = None) -> List[str]:
    """
    Get a list of compound data from a semicolon delimited string sent from the frontend
    Request data is preferably passed explicitly but global variable will be used if not.

    Args:
        field - is the key we are accessing
        request_data - the dictionary from flask.request.form/json.

    """
    if request_data:
        data0 = str(request_data[field])
    else:
        data0 = str(request.form[field])
    return data0.split(";")


# Compound hazards


def get_workgroups() -> List[str]:
    """
    Get a list of workgroup names for the current user.

    We have to check every Person Workgroup table to see if they are attached.

    Returns:
        A list of Workgroup names.
    """
    if not current_user or not current_user.is_authenticated:
        return []
    workgroups = []
    pi = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(pi)

    sr = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup_2)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(sr)

    sm = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup_3)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(sm)

    if workgroups:
        workgroups = sorted(workgroups)
    return [i.name for i in workgroups]


def get_workbooks(workgroup: str) -> List[str]:
    """
    Get a list of workbooks for a given workgroup, for the current user.

    Args:
        workgroup: name of the workgroup

    Returns:
        List of workbook names
    """
    workbooks = (
        db.session.query(models.WorkBook)
        .join(models.WorkGroup)
        .join(models.t_Person_WorkBook)
        .join(models.Person)
        .join(models.User)
        .filter(models.WorkGroup.name == workgroup)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workbooks = [x for x in workbooks if current_user.Person in x.users]
    return [i.name for i in workbooks]


def get_notification_number() -> int:
    """
    Gets the number of active notifications for the current user.

    Returns:
        Number of notifications
    """
    if not current_user or not current_user.is_authenticated:
        return 0
    return (
        db.session.query(models.Notification)
        .filter(models.Notification.status == "active")
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .count()
    )


def sanitise_user_input(input: str) -> str:
    """
    This function removes preceding, trailing, and consecutive whitespaces

    Args:
        input: input to 'sanitise'

    Returns:
        A 'sanitised' string.
    """
    return " ".join(input.split())


def security_admin_only() -> bool:
    """
    Checks if the current user is an Admin.

    Returns:
        True if user meets the criteria.
    """
    return current_user.Role.name == "Admin"


def security_pi_sr_workgroup(workgroup_name: str) -> bool:
    """
    Checks if a user is a pi or sr of workgroup.

    Args:
        workgroup_name: name of the workgroup to check

    returns:
        True if user meets the criteria.
    """
    workgroups = []
    pi = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(pi)

    sr = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup_2)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(sr)

    return workgroup_name in [i.name for i in workgroups]


def security_member_workgroup_workbook(workgroup_name: str, workbook_name: str) -> bool:
    """
    Checks if the current user is a member of a given workgroup and workbook.

    Args:
        workgroup_name: Name of the workgroup to check.
        workbook_name: Name of the workbook to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = get_workgroups()
    workbooks = get_workbooks(workgroup_name)
    return workgroup_name in workgroups and workbook_name in workbooks


def security_member_workgroup(workgroup_name: str) -> bool:
    """
    Checks if the current user is a member of a given workgroup.

    Args:
        workgroup_name: Name of the workgroup to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = get_workgroups()
    return workgroup_name in workgroups


def security_pi_workgroup(workgroup_name: str) -> bool:
    """
    Checks if the current user a is a PI of a given workgroup.

    Args:
        workgroup_name: Name of the workgroup to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )

    return workgroup_name in [i.name for i in workgroups]


def get_all_workgroup_members(
    workgroup: models.WorkGroup,
) -> Tuple[List[models.Person], List[models.Person], List[models.Person]]:
    """
    Get all workgroup members, as their respective roles.

    Args:
        workgroup:

    Returns:
         A tuple of the members in a workgroup, in their roles.
    """
    pi = (
        db.session.query(models.Person)
        .join(models.t_Person_WorkGroup)
        .join(models.WorkGroup)
        .join(models.User)
        .filter(models.WorkGroup.id == workgroup.id)
        .all()
    )
    sr = (
        db.session.query(models.Person)
        .join(models.t_Person_WorkGroup_2)
        .join(models.WorkGroup)
        .join(models.User)
        .filter(models.WorkGroup.id == workgroup.id)
        .all()
    )
    sm = (
        db.session.query(models.Person)
        .join(models.t_Person_WorkGroup_3)
        .join(models.WorkGroup)
        .join(models.User)
        .filter(models.WorkGroup.id == workgroup.id)
        .all()
    )

    return pi, sr, sm


def make_workgroup_dict() -> Dict[str, Dict[str, Union[str, Type]]]:
    """
    Build a dictionary of workgroups roles.
    """
    pi_dict = {
        "abbreviation": "pi",
        "person_to_wg_attr": "workgroup_principal_investigator",
        "wg_to_person_attr": "principal_investigator",
        "display_string": "Principal Investigator",
    }
    sr_dict = {
        "abbreviation": "sr",
        "person_to_wg_attr": "workgroup_senior_researcher",
        "wg_to_person_attr": "senior_researcher",
        "display_string": "Senior Researcher",
    }
    sm_dict = {
        "abbreviation": "sm",
        "person_to_wg_attr": "workgroup_standard_member",
        "wg_to_person_attr": "standard_member",
        "display_string": "Standard Member",
    }

    workgroup_dict_list = [pi_dict, sr_dict, sm_dict]
    workgroup_dict = {}

    for role_dict in workgroup_dict_list:
        for value in role_dict.values():
            workgroup_dict.update({value: role_dict})

    return workgroup_dict


def make_objects_inactive(
    obj_ls: Union[List[models.WGStatusRequest], List[models.Notification]]
) -> None:
    """
    Change the status in a list of objects to inactive.

    Args:
        obj_ls: The list of objects to change.
    """
    for obj in obj_ls:
        obj.status = "inactive"


workgroup_dict = make_workgroup_dict()


def remove_spaces_and_dashes(name: str) -> str:
    return name.replace(" ", "").replace("-", "")


def abort_if_user_not_in_workbook(
    workgroup_name: str, workbook_name: str, workbook: models.WorkBook
):
    """
    We abort the current process if the user is not in the workbook
    Request values come from the frontend
    """
    if workbook is not None and not security_member_workgroup_workbook(
        workgroup_name, workbook_name
    ):
        abort(401)
