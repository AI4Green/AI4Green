#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This module contains auxiliary variables and functions used throughout the app
"""
import os.path  # module for pathname manipulates
import re
from typing import Dict, List, Optional, Tuple, Type, Union

from flask import abort, request
from flask_login import current_user
from rdkit import Chem  # Used for converting smiles to inchi
from sources import models
from sources.extensions import db

"""This defines absolute paths to databases"""
BASE_DIR = os.path.dirname(
    os.path.abspath(__file__)
)  # absolute path to the directory containing this file


def replace_symbols(
    compound: str,
) -> str:  # restores the initial smiles string with the sharp, plus and minus symbols
    compound = compound.replace("sharp", "%23")
    compound = compound.replace("plus", "%2B")
    return compound.replace("minus", "%2D")


def code_symbols(
    compound: str,
) -> str:  # converts the sharp, plus, and minus symbols into the URL encoding format
    compound = compound.replace("#", "%23")
    compound = compound.replace("+", "%2B")
    return compound.replace("-", "%2D")


def smiles_symbols(
    compound: str,
) -> (
    str
):  # restores the sharp plus and minus symbols from the string generated by marvinJS
    return compound.replace("minus", "-").replace("plus", "+").replace("sharp", "#")


def get_data(field: str, request_data: Optional[Dict] = None) -> List[str]:
    """
    Get a list of compound data from a semicolon delimited string sent from the frontend
    Request data is preferably passed explicitly but global variable will be used if not.

    Args:
        field - is the key we are accessing
        request_data - the dictionary from flask.request.form/json.

    """
    if request_data:
        data0 = str(request_data[field])
    else:
        data0 = str(request.form[field])
    return data0.split(";")


# Compound hazards


def get_workgroups() -> List[str]:
    """
    Get a list of workgroup names for the current user.

    We have to check every Person Workgroup table to see if they are attached.

    Returns:
        A list of Workgroup names.
    """
    if not current_user or not current_user.is_authenticated:
        return []
    workgroups = []
    pi = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(pi)

    sr = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup_2)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(sr)

    sm = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup_3)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(sm)

    if workgroups:
        workgroups = sorted(workgroups)
    return [i.name for i in workgroups]


def get_workbooks(workgroup: str) -> List[str]:
    """
    Get a list of workbooks for a given workgroup, for the current user.

    Args:
        workgroup: name of the workgroup

    Returns:
        List of workbook names
    """
    workbooks = (
        db.session.query(models.WorkBook)
        .join(models.WorkGroup)
        .join(models.t_Person_WorkBook)
        .join(models.Person)
        .join(models.User)
        .filter(models.WorkGroup.name == workgroup)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workbooks = [x for x in workbooks if current_user.Person in x.users]
    return [i.name for i in workbooks]


def get_notification_number() -> int:
    """
    Gets the number of active notifications for the current user.

    Returns:
        Number of notifications
    """
    if not current_user or not current_user.is_authenticated:
        return 0
    return (
        db.session.query(models.Notification)
        .filter(models.Notification.status == "active")
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .count()
    )


def sanitise_user_input(input: str) -> str:
    """
    This function removes preceding, trailing, and consecutive whitespaces

    Args:
        input: input to 'sanitise'

    Returns:
        A 'sanitised' string.
    """
    return " ".join(input.split())


def security_admin_only() -> bool:
    """
    Checks if the current user is an Admin.

    Returns:
        True if user meets the criteria.
    """
    return current_user.Role.name == "Admin"


def security_pi_sr_workgroup(workgroup_name: str) -> bool:
    """
    Checks if a user is a pi or sr of workgroup.

    Args:
        workgroup_name: name of the workgroup to check

    returns:
        True if user meets the criteria.
    """
    workgroups = []
    pi = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(pi)

    sr = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup_2)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )
    workgroups.extend(sr)

    return workgroup_name in [i.name for i in workgroups]


def security_member_workgroup_workbook(workgroup_name: str, workbook_name: str) -> bool:
    """
    Checks if the current user is a member of a given workgroup and workbook.

    Args:
        workgroup_name: Name of the workgroup to check.
        workbook_name: Name of the workbook to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = get_workgroups()
    workbooks = get_workbooks(workgroup_name)
    return workgroup_name in workgroups and workbook_name in workbooks


def security_member_workgroup(workgroup_name: str) -> bool:
    """
    Checks if the current user is a member of a given workgroup.

    Args:
        workgroup_name: Name of the workgroup to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = get_workgroups()
    return workgroup_name in workgroups


def security_pi_workgroup(workgroup_name: str) -> bool:
    """
    Checks if the current user a is a PI of a given workgroup.

    Args:
        workgroup_name: Name of the workgroup to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .all()
    )

    return workgroup_name in [i.name for i in workgroups]


def duplicate_notification_check(
    people_ls: List[models.Person],
    request_type: str,
    status,
    WG: str,
    WB: models.WorkBook = None,
) -> bool:
    """
    Check if the request has already been made - if someone already has received your request they will be
    removed from the list of people to be sent the request
    """
    refined_people_ls = []
    for person in people_ls:
        if WB:
            check = (
                db.session.query(models.Notification)
                .filter(models.Notification.wb == WB and models.Notification.wg == WG)
                .join(models.WBStatusRequest)
                .join(models.Person, models.WBStatusRequest.person == models.Person.id)
                .filter(models.Person.id == person.id)
                .first()
            )
        else:
            if request_type == "New Workgroup Membership Request":
                # check for person applying to join workgroup - 1 PI may have many requests from different users
                check = (
                    db.session.query(models.Notification)
                    .filter(models.Notification.wg == WG)
                    .join(models.WGStatusRequest)
                    .join(
                        models.Person, models.WGStatusRequest.person == models.Person.id
                    )
                    .filter(models.Person == person.id)
                    .first()
                )
            elif request_type == "New Workgroup Role Reassignment Request":
                check = (
                    db.session.query(models.Notification)
                    .filter(models.Notification.wg == WG)
                    .join(models.WGStatusRequest)
                    .join(
                        models.Person, models.WGStatusRequest.person == models.Person.id
                    )
                    .filter(models.Person.id == person.id)
                    .first()
                )
            else:
                check = (
                    db.session.query(models.Notification)
                    .filter(models.Notification.wg == WG)
                    .filter(models.Notification.status == status)
                    .filter(models.Notification.type == request_type)
                    .join(models.WGStatusRequest)
                    .join(
                        models.Person, models.WGStatusRequest.person == models.Person.id
                    )
                    .filter(models.Person.id == person.id)
                    .first()
                )

        if check is None:
            refined_people_ls.append(person)
    return not refined_people_ls


def get_all_workgroup_members(
    workgroup: models.WorkGroup,
) -> Tuple[List[models.Person], List[models.Person], List[models.Person]]:
    """
    Get all workgroup members, as their respective roles.

    Args:
        workgroup:

    Returns:
         A tuple of the members in a workgroup, in their roles.
    """
    pi = (
        db.session.query(models.Person)
        .join(models.t_Person_WorkGroup)
        .join(models.WorkGroup)
        .join(models.User)
        .filter(models.WorkGroup.id == workgroup.id)
        .all()
    )
    sr = (
        db.session.query(models.Person)
        .join(models.t_Person_WorkGroup_2)
        .join(models.WorkGroup)
        .join(models.User)
        .filter(models.WorkGroup.id == workgroup.id)
        .all()
    )
    sm = (
        db.session.query(models.Person)
        .join(models.t_Person_WorkGroup_3)
        .join(models.WorkGroup)
        .join(models.User)
        .filter(models.WorkGroup.id == workgroup.id)
        .all()
    )

    return pi, sr, sm


def make_workgroup_dict() -> Dict[str, Dict[str, Union[str, Type]]]:
    """
    Build a dictionary of workgroups roles.
    """
    pi_dict = {
        "abbreviation": "pi",
        "person_to_wg_attr": "workgroup_principal_investigator",
        "wg_to_person_attr": "principal_investigator",
        "display_string": "Principal Investigator",
    }
    sr_dict = {
        "abbreviation": "sr",
        "person_to_wg_attr": "workgroup_senior_researcher",
        "wg_to_person_attr": "senior_researcher",
        "display_string": "Senior Researcher",
    }
    sm_dict = {
        "abbreviation": "sm",
        "person_to_wg_attr": "workgroup_standard_member",
        "wg_to_person_attr": "standard_member",
        "display_string": "Standard Member",
    }

    workgroup_dict_list = [pi_dict, sr_dict, sm_dict]
    workgroup_dict = {}

    for role_dict in workgroup_dict_list:
        for value in role_dict.values():
            workgroup_dict.update({value: role_dict})

    return workgroup_dict


def make_objects_inactive(
    obj_ls: Union[List[models.WGStatusRequest], List[models.Notification]]
) -> None:
    """
    Change the status in a list of objects to inactive.

    Args:
        obj_ls: The list of objects to change.
    """
    for obj in obj_ls:
        obj.status = "inactive"


workgroup_dict = make_workgroup_dict()


def get_smiles(ids: List[str]) -> List[str]:
    """
    Get the smiles from a list of Compound Ids.

    Args:
       ids: The List of compound ids

    Returns:
        A list of smiles :)
    """
    smiles = []
    for id_value in ids:
        if id_value.isdigit():
            compound = (
                db.session.query(models.Compound)
                .filter(models.Compound.id == id_value)
                .first()
            )
        else:
            # novel compound id values in format: "('compound name', workbook_id_integer)"
            # find compound name via regex and workbook id via regular expressions then query database
            compound_name = re.search(r"'([^']+)'", id_value).group().strip("'")
            workbook_id = int(re.search(r"'.*?'\s*,\s*(\d+)", id_value).group(1))
            compound = (
                db.session.query(models.NovelCompound)
                .filter(models.NovelCompound.name == compound_name)
                .filter(models.NovelCompound.workbook == workbook_id)
                .first()
            )
        smiles.append(compound.smiles)
    return smiles


def smiles_to_inchi(smiles: str) -> Optional[str]:
    """
    Convert a smiles string to an InChI string using RDKit.

    Args:
        smiles: The input SMILES string to convert.

    Returns:
        The InChI string if the conversion is successful,
        or None if the conversion fails.
    """
    mol = Chem.MolFromSmiles(smiles)
    try:
        return Chem.MolToInchi(mol)
    except Exception:
        return None


def remove_spaces_and_dashes(name: str) -> str:
    return name.replace(" ", "").replace("-", "")


def abort_if_user_not_in_workbook(
    workgroup_name: str, workbook_name: str, workbook: models.WorkBook
):
    """
    We abort the current process if the user is not in the workbook
    Request values come from the frontend
    """
    if workbook is not None and not security_member_workgroup_workbook(
        workgroup_name, workbook_name
    ):
        abort(401)
