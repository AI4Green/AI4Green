#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This module contains auxiliary variables and functions used throughout the app
"""
import os.path # module for pathname manipulates
from typing import Dict, List, Optional, Type, Union, Tuple
from flask import request  # parses incoming request data and gives access to it
from sources.extensions import db
from sources import models
from flask_login import current_user
import re
from rdkit import Chem  # Used for converting smiles to inchi

'''This defines absolute paths to databases'''
BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # absolute path to the directory containing this file
reagents_db_path = os.path.join(BASE_DIR, "reagents_pubchem.db")
solvents_db_path = os.path.join(BASE_DIR, "solvents.db")
hazard_codes_db_path = os.path.join(BASE_DIR, "hazard_codes.db")
reactions_db_path = os.path.join(BASE_DIR, "reactions.db")


def replace_symbols(compound: str) -> str:  # restores the initial smiles string with the sharp, plus and minus symbols
    compound = compound.replace('sharp', '%23')
    compound = compound.replace('plus', '%2B')
    return compound.replace('minus', '%2D')


def code_symbols(compound: str) -> str:  # converts the sharp, plus, and minus symbols into the URL encoding format
    compound = compound.replace('#', '%23')
    compound = compound.replace('+', '%2B')
    return compound.replace('-', '%2D')


def smiles_symbols(compound: str) -> str:  # restores the sharp plus and minus symbols from the string generated by marvinJS
    compound = compound.replace('sharp', '#')
    compound = compound.replace('plus', '+')
    return compound.replace('minus', '-')


def metric_flag(metric: int) -> str:
    """
    Colour flags for metrics
    """
    if metric > 90:
        return "hazard-acceptable"
    elif metric < 70:
        return "hazard-hazardous"
    else:
        return "hazard-warning"


def get_data(field) -> List[str]:
    """
    Get reactant data.
    """
    data0 = str(request.form[field])
    return data0.split(";")


# Compound hazards
def compound_hazard_data(compounds, compound_hazards, compound_physical_forms):
    """
    This function gets compounds, their hazards and physical forms, and returns
    hazard sentences, hazard ratings, hazard and risk color codes, exposure potentials,
    risk ratings, and total hazard rates
    TODO: Refactor this function.
    """
    total_rate = [0]  # the list of maximum hazard rates
    if compounds[0]:
        category_rate = {'': 0, 'L': 1, 'M': 2, 'H': 3, 'VH': 4}  # 'risk category - rate' dictionary
        # '' - no category
        # 'L' - low risk
        # 'M' - medium risk
        # 'H' - high risk
        # 'VH' - very high risk
        physical_form_exposure_potential = {  # physical form - risk category' dictionary
            '-select-': 'M',
            'Dense solid': 'L',
            'Non-volatile liquid': 'L',
            'Unknown': 'M',
            'Dusty Solid': 'M',
            'Lyophilised solid': 'M',
            'Volatile liquid': 'M',
            'Gas': 'H',
            'Highly volatile liquid': 'H',
            'Aerosol': 'H',
            'Solution that promotes skin absorption': 'H'
        }
        hazard_exposure_risk = {  # 'combination of risks - risk category' dictionary
            'VHL': 'H',
            'VHM': 'VH',
            'VHH': 'VH',
            'HL': 'M',
            'HM': 'H',
            'HH': 'H',
            'ML': 'L',
            'MM': 'M',
            'MH': 'H',
            'LL': 'L',
            'LM': 'L',
            'LH': 'M',
        }
        compound_hazard_sentences = []  # the list of compound hazard sentences
        compound_hazard_ratings = []  # the list of compound hazard ratings
        compound_hazard_colors = []  # list of compound hazard colors
        for compound_hazard in compound_hazards:
            compound_rates = [0]
            if compound_hazard not in {"Not Hazardous", "No hazard codes found"}:
                '''First, we separate hazard codes from each other in the hazard string'''
                compound_hazard1 = compound_hazard.replace("   ", ",")
                compound_hazard1 = compound_hazard1.replace("-", ",")
                compound_hazard2 = compound_hazard1.replace(" + ", ",")
                compound_hazard3 = compound_hazard2.replace("+", ",")
                compound_codes = sorted(list(set(compound_hazard3.split(","))))
                ''''''
                compound_hazard_sentence = ""  # joins hazard codes and phrases
                for compound_code in compound_codes:
                    '''We use a hazard code to query the hazard database 
                    and return a corresponding hazard phrase and risk category'''
                    compound = db.session.query(models.HazardCode).filter(models.HazardCode.code==compound_code).first()
                    compound_phrase = compound.phrase  # appends the risk rate to its list
                    compound_hazard_sentence += compound_code + " " + compound_phrase + ", "  # the hazard sentence
                    compound_rate = category_rate.get(compound.category)
                    if compound_rate is not None:
                        compound_rates.append(compound_rate)
                compound_hazard_sentence = compound_hazard_sentence[:-2]  # removes the comma and space at the end
                max_compound_rate = int(max(compound_rates))  # maximum risk rate
                total_rate.append(max_compound_rate)  # appends the maximum risk rate to their list
                compound_hazard_rating = list(category_rate.keys())[max_compound_rate] \
                    if max_compound_rate > 0 else 'M'  # converts the risk rates to hazard ratings
                # if the maximum risk rate is 0, then the hazard rating is M - medium
            else:  # if the compound is not hazardous,
                compound_hazard_sentence = compound_hazard  # then the hazard sentence is 'Not hazardous'
                compound_hazard_rating = 'L'  # and its hazard rating is L - low
            compound_hazard_sentences.append(compound_hazard_sentence)  # appends the hazard sentence to their list
            compound_hazard_ratings.append(compound_hazard_rating)  # appends the hazard rating to their list
            compound_hazard_color = 'hazard-hazardous' if compound_hazard_rating == 'VH' else 'hazard-reset-hazard'  # assigns color codes
            compound_hazard_colors.append(compound_hazard_color)  # appending the table cell colour to their list
        compound_exposure_potentials = []  # list of exposure potentials
        for compound_physical_form in compound_physical_forms:
            # converts physical forms to exposure potentials
            compound_exposure_potential = physical_form_exposure_potential.get(compound_physical_form)
            compound_exposure_potentials.append(compound_exposure_potential)
        compound_hazard_exposures = [compound_hazard_rating + compound_exposure_potential
                                     for (compound_hazard_rating, compound_exposure_potential)
                                     in zip(compound_hazard_ratings, compound_exposure_potentials)]
        # combines hazard ratings and exposure potentials
        compound_risk_ratings = []  # the risk rating list
        compound_risk_colors = []  # the risk colour list
        for compound_hazard_exposure in compound_hazard_exposures:
            # converts hazard exposures to risk ratings and assigns color codes to them
            compound_risk_rating = hazard_exposure_risk.get(compound_hazard_exposure)
            compound_risk_ratings.append(compound_risk_rating)
            compound_risk_color = 'hazard-hazardous' if compound_risk_rating == 'VH' else 'hazard-reset-hazard'
            compound_risk_colors.append(compound_risk_color)
    else:
        compound_hazard_sentences = ""
        compound_hazard_ratings = ""
        compound_hazard_colors = ""
        compound_risk_colors = ""
        compound_exposure_potentials = ""
        compound_risk_ratings = ""

    return compound_hazard_sentences, compound_hazard_ratings, compound_hazard_colors, \
        compound_risk_colors, compound_exposure_potentials, compound_risk_ratings, total_rate


def get_workgroups() -> List[str]:
    """
    Get a list of workgroup names for the current user.

    We have to check every Person Workgroup table to see if they are attached.

    Returns:
        A list of Workgroup names.
    """
    workgroups = []
    pi = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email==current_user.email)
        .all()
    )
    workgroups.extend(pi)
    
    sr = (
        db.session.query(models.WorkGroup.name)
        .join(models.t_Person_WorkGroup_2)
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email==current_user.email)
        .all()
    )
    workgroups.extend(sr)

    sm = db.session.query(models.WorkGroup.name).join(
        models.t_Person_WorkGroup_3).join(
        models.Person).join(
        models.User).filter(
        models.User.email==current_user.email).all()
    workgroups.extend(sm)

    if workgroups:
        workgroups = sorted(workgroups)
    return [i.name for i in workgroups]


def get_workbooks(workgroup: str) -> List[str]:
    """
    Get a list of workbooks for a given workgroup, for the current user.

    Args:
        workgroup: name of the workgroup

    Returns:
        List of workbook names
    """
    workbooks = (
        db.session.query(models.WorkBook)
        .join(models.WorkGroup)
        .join(models.t_Person_WorkBook)
        .join(models.Person)
        .join(models.User)
        .filter(models.WorkGroup.name == workgroup)
        .filter(models.User.email == current_user.email)
        .all()
    )
    return [i.name for i in workbooks]


def get_notification_number() -> int:
    """
    Gets the number of active notifications for the current user.

    Returns:
        Number of notifications
    """
    return (
        db.session.query(models.Notification)
        .filter(models.Notification.status == "active")
        .join(models.Person)
        .join(models.User)
        .filter(models.User.email == current_user.email)
        .count()
    )


def sanitise_user_input(input: str) -> str:
    """
    This function removes preceding, trailing, and consecutive whitespaces

    Args:
        input: input to 'sanitise'

    Returns:
        A 'sanitised' string.
    """
    return " ".join(input.split())


def security_admin_only() -> bool:
    """
    Checks if the current user is an Admin.

    Returns:
        True if user meets the criteria.
    """
    return current_user.Role.name == "Admin"


def security_pi_sr_workgroup(workgroup_name: str) -> bool:
    """
    Checks if a user is a pi or sr of workgroup.
    
    Args:
        workgroup_name: name of the workgroup to check

    returns: 
        True if user meets the criteria.
    """
    workgroups = []
    pi = db.session.query(models.WorkGroup.name).join(
        models.t_Person_WorkGroup).join(
        models.Person).join(
        models.User).filter(
        models.User.email==current_user.email).all()
    workgroups.extend(pi)
    
    sr = db.session.query(models.WorkGroup.name).join(
        models.t_Person_WorkGroup_2).join(
        models.Person).join(
        models.User).filter(
        models.User.email==current_user.email).all()
    workgroups.extend(sr)

    return workgroup_name in [i.name for i in workgroups]


def security_member_workgroup_workbook(workgroup_name: str, workbook_name: str) -> bool:
    """
    Checks if the current user is a member of a given workgroup and workbook.

    Args:
        workgroup_name: Name of the workgroup to check.
        workbook_name: Name of the workbook to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = get_workgroups()
    workbooks = get_workbooks(workgroup_name)
    return workgroup_name in workgroups and workbook_name in workbooks


def security_member_workgroup(workgroup_name: str) -> bool:
    """
    Checks if the current user is a member of a given workgroup.

    Args:
        workgroup_name: Name of the workgroup to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = get_workgroups()
    return workgroup_name in workgroups


def security_pi_workgroup(workgroup_name: str) -> bool:
    """
    Checks if the current user a is a PI of a given workgroup.

    Args:
        workgroup_name: Name of the workgroup to check.

    Returns:
        True if the user meets the criteria.
    """
    workgroups = (db.session.query(models.WorkGroup.name)
                  .join(models.t_Person_WorkGroup)
                  .join(models.Person)
                  .join(models.User)
                  .filter(models.User.email==current_user.email)
                  .all()
                  )
    
    return workgroup_name in [i.name for i in workgroups]
    

def duplicate_notification_check(people_ls: List[models.Person], request_type: str, status, WG: str, WB: models.WorkBook=None) -> bool:
    """
    Check if the request has already been made - if someone already has received your request they will be
    removed from the list of people to be sent the request
    """
    refined_people_ls = []
    for person in people_ls:
        if WB:
            check = (
                db.session.query(models.Notification)
                .filter(models.Notification.wb == WB and models.Notification.wg == WG)
                .join(models.WBStatusRequest)
                .join(models.Person, models.WBStatusRequest.person == models.Person.id)
                .filter(models.Person.id == person.id)
                .first()
            )
        else:
            if request_type == "New Workgroup Membership Request":
                # check for person applying to join workgroup - 1 PI may have many requests from different users
                check = (
                    db.session.query(models.Notification)
                    .filter(models.Notification.wg == WG)
                    .join(models.WGStatusRequest)
                    .join(models.Person, models.WGStatusRequest.person == models.Person.id)
                    .filter(models.Person == person.id)
                    .first()
                )
            elif request_type == "New Workgroup Role Reassignment Request":
                check = (
                    db.session.query(models.Notification)
                    .filter(models.Notification.wg == WG)
                    .join(models.WGStatusRequest)
                    .join(models.Person, models.WGStatusRequest.person == models.Person.id)
                    .filter(models.Person.id == person.id)
                    .first()
                )
            else:
                check = (
                    db.session.query(models.Notification)
                    .filter(models.Notification.wg == WG)
                    .filter(models.Notification.status == status)
                    .filter(models.Notification.type == request_type)
                    .join(models.WGStatusRequest)
                    .join(models.Person, models.WGStatusRequest.person == models.Person.id)
                    .filter(models.Person.id == person.id)
                    .first()
                )

        if check is None:
            refined_people_ls.append(person)
    return not refined_people_ls


def get_all_workgroup_members(workgroup: models.WorkGroup) -> Tuple[List[models.Person], List[models.Person], List[models.Person]]:
    """
    Get all workgroup members, as their respective roles.

    Args:
        workgroup: 

    Returns:
         A tuple of the members in a workgroup, in their roles.
    """
    pi = db.session.query(models.Person).join(
        models.t_Person_WorkGroup).join(
        models.WorkGroup).join(
        models.User).filter(
        models.WorkGroup.id==workgroup.id).all()
    sr = db.session.query(models.Person).join(
        models.t_Person_WorkGroup_2).join(
        models.WorkGroup).join(
        models.User).filter(
        models.WorkGroup.id==workgroup.id).all()
    sm = db.session.query(models.Person).join(
        models.t_Person_WorkGroup_3).join(
        models.WorkGroup).join(
        models.User).filter(
        models.WorkGroup.id==workgroup.id).all()

    return pi, sr, sm


def make_workgroup_dict() -> Dict[str, Dict[str, Union[str, Type]]]:
    """
    Build a dictionary of workgroups roles.
    """
    pi_dict = {"abbreviation": "pi",
               "person_to_wg_attr": "workgroup_principal_investigator",
               "wg_to_person_attr": "principal_investigator",
               "display_string": "Principal Investigator"}
    sr_dict = {"abbreviation": "sr",
               "person_to_wg_attr": "workgroup_senior_researcher",
               "wg_to_person_attr": "senior_researcher",
               "display_string": "Senior Researcher"}
    sm_dict = {"abbreviation": "sm",
               "person_to_wg_attr": "workgroup_standard_member",
               "wg_to_person_attr": "standard_member",
               "display_string": "Standard Member"}

    workgroup_dict_list = [pi_dict, sr_dict, sm_dict]
    workgroup_dict = {}

    for role_dict in workgroup_dict_list:
        for value in role_dict.values():
            workgroup_dict.update({value: role_dict})

    return workgroup_dict


def make_objects_inactive(obj_ls : Union[List[models.WGStatusRequest], List[models.Notification]]) -> None:
    """
    Change the status in a list of objects to inactive.

    Args:
        obj_ls: The list of objects to change.
    """
    for obj in obj_ls:
        obj.status = "inactive"


workgroup_dict = make_workgroup_dict()


def get_smiles(ids : List[str]) -> List[str]:
    """
    Get the smiles from a list of Compound Ids.

    Args:
       ids: The List of compound ids

    Returns:
        A list of smiles :)
    """
    smiles = []
    for id_value in ids:
        if id_value.isdigit():
            compound = db.session.query(models.Compound).filter(models.Compound.id == id_value).first()
        else:
            species_name = re.findall("\'.*\'", id_value)[0]
            species_name = species_name[1:]
            species_name = species_name[:-1]
            workbook_id = id_value.replace(species_name, "")
            workbook_id = re.findall("\d+", workbook_id)[0]
            compound = (
                db.session.query(models.NovelCompound)
                .filter(models.NovelCompound.name == species_name)
                .filter(models.NovelCompound.workbook == workbook_id)
                .first()
            )
        smiles.append(compound.smiles)
    return smiles


def smiles_to_inchi(smiles: str) -> Optional[str]:
    """
    Convert a smiles string to an InChI string using RDKit.

    Args:
        smiles: The input SMILES string to convert.

    Returns:
        The InChI string if the conversion is successful, 
        or None if the conversion fails.
    """
    mol = Chem.MolFromSmiles(smiles)
    try:
        return Chem.MolToInchi(mol)
    except Exception:
        return None


def remove_spaces_and_dashes(name: str) -> str:
    return name.replace(' ', '').replace('-', '')
