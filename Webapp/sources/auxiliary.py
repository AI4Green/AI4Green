#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This module contains auxiliary variables and functions used throughout the app
"""
import ast
import os.path  # module for pathname manipulates
from flask import request  # parses incoming request data and gives access to it
from pony.orm import select
from sources import db
from flask_login import current_user
import re

'''This defines absolute paths to databases'''
BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # absolute path to the directory containing this file
reagents_db_path = os.path.join(BASE_DIR, "reagents_pubchem.db")
solvents_db_path = os.path.join(BASE_DIR, "solvents.db")
hazard_codes_db_path = os.path.join(BASE_DIR, "hazard_codes.db")
reactions_db_path = os.path.join(BASE_DIR, "reactions.db")


def replace_symbols(compound):  # restores the initial smiles string with the sharp, plus and minus symbols
    compound = compound.replace('sharp', '%23')
    compound = compound.replace('plus', '%2B')
    compound = compound.replace('minus', '%2D')
    return compound


def code_symbols(compound):  # converts the sharp, plus, and minus symbols into the URL encoding format
    compound = compound.replace('#', '%23')
    compound = compound.replace('+', '%2B')
    compound = compound.replace('-', '%2D')
    return compound


def smiles_symbols(compound):  # restores the sharp plus and minus symbols from the string generated by marvinJS
    compound = compound.replace('sharp', '#')
    compound = compound.replace('plus', '+')
    compound = compound.replace('minus', '-')
    return compound


# Colour flags for metrics
def metric_flag(metric):
    if metric > 90:
        flag = "hazard-acceptable"
    elif metric < 70:
        flag = "hazard-hazardous"
    else:
        flag = "hazard-warning"
    return flag


# Get reactant data
def get_data(field):
    data0 = str(request.form[field])
    data = data0.split(";")
    return data


# Compound hazards
def compound_hazard_data(compounds, compound_hazards, compound_physical_forms):
    """This function gets compounds, their hazards and physical forms, and returns
    hazard sentences, hazard ratings, hazard and risk color codes, exposure potentials,
    risk ratings, and total hazard rates"""
    total_rate = [0]  # the list of maximum hazard rates
    if compounds[0]:
        category_rate = {'': 0, 'L': 1, 'M': 2, 'H': 3, 'VH': 4}  # 'risk category - rate' dictionary
        # '' - no category
        # 'L' - low risk
        # 'M' - medium risk
        # 'H' - high risk
        # 'VH' - very high risk
        physical_form_exposure_potential = {  # physical form - risk category' dictionary
            '-select-': 'M',
            'Dense solid': 'L',
            'Non-volatile liquid': 'L',
            'Unknown': 'M',
            'Dusty Solid': 'M',
            'Lyophilised solid': 'M',
            'Volatile liquid': 'M',
            'Gas': 'H',
            'Highly volatile liquid': 'H',
            'Aerosol': 'H',
            'Solution that promotes skin absorption': 'H'
        }
        hazard_exposure_risk = {  # 'combination of risks - risk category' dictionary
            'VHL': 'H',
            'VHM': 'VH',
            'VHH': 'VH',
            'HL': 'M',
            'HM': 'H',
            'HH': 'H',
            'ML': 'L',
            'MM': 'M',
            'MH': 'H',
            'LL': 'L',
            'LM': 'L',
            'LH': 'M',
        }
        compound_hazard_sentences = []  # the list of compound hazard sentences
        compound_hazard_ratings = []  # the list of compound hazard ratings
        compound_hazard_colors = []  # list of compound hazard colors
        for compound_hazard in compound_hazards:
            compound_rates = [0]
            if compound_hazard not in {"Not Hazardous", "No hazard codes found"}:
                '''First, we separate hazard codes from each other in the hazard string'''
                compound_hazard1 = compound_hazard.replace("   ", ",")
                compound_hazard1 = compound_hazard1.replace("-", ",")
                compound_hazard2 = compound_hazard1.replace(" + ", ",")
                compound_hazard3 = compound_hazard2.replace("+", ",")
                compound_codes = sorted(list(set(compound_hazard3.split(","))))
                ''''''
                compound_hazard_sentence = ""  # joins hazard codes and phrases
                for compound_code in compound_codes:
                    '''We use a hazard code to query the hazard database 
                    and return a corresponding hazard phrase and risk category'''
                    compound = select(c for c in db.HazardCode if c.code == compound_code).first()
                    compound_phrase = compound.phrase
                    compound_rate = category_rate.get(compound.category)
                    compound_rates.append(compound_rate)  # appends the risk rate to its list
                    compound_hazard_sentence += compound_code + " " + compound_phrase + ", "  # the hazard sentence
                compound_hazard_sentence = compound_hazard_sentence[:-2]  # removes the comma and space at the end
                max_compound_rate = int(max(compound_rates))  # maximum risk rate
                total_rate.append(max_compound_rate)  # appends the maximum risk rate to their list
                compound_hazard_rating = list(category_rate.keys())[max_compound_rate] \
                    if max_compound_rate > 0 else 'M'  # converts the risk rates to hazard ratings
                # if the maximum risk rate is 0, then the hazard rating is M - medium
            else:  # if the compound is not hazardous,
                compound_hazard_sentence = compound_hazard  # then the hazard sentence is 'Not hazardous'
                compound_hazard_rating = 'L'  # and its hazard rating is L - low
            compound_hazard_sentences.append(compound_hazard_sentence)  # appends the hazard sentence to their list
            compound_hazard_ratings.append(compound_hazard_rating)  # appends the hazard rating to their list
            compound_hazard_color = 'hazard-hazardous' if compound_hazard_rating == 'VH' else 'hazard-reset-hazard'  # assigns color codes
            compound_hazard_colors.append(compound_hazard_color)  # appending the table cell colour to their list
        compound_exposure_potentials = []  # list of exposure potentials
        for compound_physical_form in compound_physical_forms:
            # converts physical forms to exposure potentials
            compound_exposure_potential = physical_form_exposure_potential.get(compound_physical_form)
            compound_exposure_potentials.append(compound_exposure_potential)
        compound_hazard_exposures = [compound_hazard_rating + compound_exposure_potential
                                     for (compound_hazard_rating, compound_exposure_potential)
                                     in zip(compound_hazard_ratings, compound_exposure_potentials)]
        # combines hazard ratings and exposure potentials
        compound_risk_ratings = []  # the risk rating list
        compound_risk_colors = []  # the risk colour list
        for compound_hazard_exposure in compound_hazard_exposures:
            # converts hazard exposures to risk ratings and assigns color codes to them
            compound_risk_rating = hazard_exposure_risk.get(compound_hazard_exposure)
            compound_risk_ratings.append(compound_risk_rating)
            compound_risk_color = 'hazard-hazardous' if compound_risk_rating == 'VH' else 'hazard-reset-hazard'
            compound_risk_colors.append(compound_risk_color)
    else:
        compound_hazard_sentences = ""
        compound_hazard_ratings = ""
        compound_hazard_colors = ""
        compound_risk_colors = ""
        compound_exposure_potentials = ""
        compound_risk_ratings = ""

    return compound_hazard_sentences, compound_hazard_ratings, compound_hazard_colors, \
        compound_risk_colors, compound_exposure_potentials, compound_risk_ratings, total_rate


def get_workgroups():
    workgroups = []
    for workgroup in select(u.name for u in db.WorkGroup if current_user.email in u.principal_investigator.user.email):
        workgroups.append(workgroup)
    for workgroup in select(u.name for u in db.WorkGroup if current_user.email in u.senior_researcher.user.email):
        workgroups.append(workgroup)
    for workgroup in select(u.name for u in db.WorkGroup if current_user.email in u.standard_member.user.email):
        workgroups.append(workgroup)
    if workgroups:
        workgroups = sorted(workgroups)
    return workgroups


def get_workbooks(workgroup):
    workbooks = []
    for workbook in select(u.name for u in db.WorkBook if current_user.email in u.users.user.email
                           and u.group.name == workgroup):
        workbooks.append(workbook)
    return workbooks


def get_notification_number():
    notification_number = select(x for x in db.Notification if x.person.user.email == current_user.email and x.status == "active")[:]
    if notification_number:
        notification_number = len(notification_number)
    return notification_number


def sanitise_user_input(input_str: str):
    """This function removes preceding, trailing, and consecutive whitespaces"""
    # remove preceding and trailing whitespaces
    sanitised_input = " ".join(input_str.split())
    return sanitised_input


def security_admin_only():
    # if admin return True
    if current_user.role.name == "Admin":
        return True
    else:
        return False


def security_pi_sr_workgroup(workgroup_name):
    # if a pi or sr of workgroup return True
    workgroups = []
    for workgroup in select(u.name for u in db.WorkGroup if current_user.email in u.principal_investigator.user.email):
        workgroups.append(workgroup)
    for workgroup in select(u.name for u in db.WorkGroup if current_user.email in u.senior_researcher.user.email):
        workgroups.append(workgroup)
    if workgroup_name in workgroups:
        return True
    else:
        return False


def security_member_workgroup_workbook(workgroup_name, workbook_name):
    # if member of both workgroup and workbook return True
    workgroups = get_workgroups()
    workbooks = get_workbooks(workgroup_name)
    if workgroup_name in workgroups:
        if workbook_name in workbooks:
            return True
        else:
            return False
    else:
        return False


def security_member_workgroup(workgroup_name):
    workgroups = get_workgroups()
    if workgroup_name in workgroups:
        return True
    else:
        return False


def security_pi_workgroup(workgroup_name):
    # if a pi of workgroup return True
    workgroups = []
    for workgroup in select(u.name for u in db.WorkGroup if current_user.email in u.principal_investigator.user.email):
        workgroups.append(workgroup)
    if workgroup_name in workgroups:
        return True
    else:
        return False


def duplicate_notification_check(people_ls, request_type, status, WG, WB=None):
    """Check if the request has already been made - if someone already has received your request they will be
    removed from the list of people to be sent the request"""
    refined_people_ls = []
    for person in people_ls:
        if WB:
            # check = select(x for x in db.Notification if x.person == person and x.type == request_type
            #                 and x.status == status and x.WG == WG and x.WB == WB).first()
            check = select(x for x in db.Notification if person in x.wb_status_notification.person
                           and x.WB == WB and x.WG == WG).first()
        else:
            if request_type == "New Workgroup Membership Request":
                # check for person applying to join workgroup - 1 PI may have many requests from different users
                check = select(x for x in db.Notification if person in x.wg_status_notification.person
                               and x.WG == WG).first()
            elif request_type == "New Workgroup Role Reassignment Request":
                check = select(x for x in db.Notification if person in x.wg_status_notification.person
                               and x.WG == WG).first()
            else:
                check = select(x for x in db.Notification if x.person == person and x.type == request_type
                               and x.status == status and x.WG == WG).first()
        if check is None:
            refined_people_ls.append(person)
    if len(refined_people_ls) == 0:
        return True
    else:
        return False


def get_all_workgroup_member_types(workgroup):
    pi = select(x for x in workgroup.principal_investigator)[:]
    sr = select(x for x in workgroup.senior_researcher)[:]
    sm = select(x for x in workgroup.standard_member)[:]
    return pi, sr, sm


def make_workgroup_dict():
    pi_dict = {"abbreviation": "pi",
               "person_to_wg_attr": "workgroup_principal_investigator",
               "wg_to_person_attr": "principal_investigator",
               "display_string": "Principal Investigator"}
    sr_dict = {"abbreviation": "sr",
               "person_to_wg_attr": "workgroup_senior_researcher",
               "wg_to_person_attr": "senior_researcher",
               "display_string": "Senior Researcher"}
    sm_dict = {"abbreviation": "sm",
               "person_to_wg_attr": "workgroup_standard_member",
               "wg_to_person_attr": "standard_member",
               "display_string": "Standard Member"}

    workgroup_dict_list = [pi_dict, sr_dict, sm_dict]
    workgroup_dict = {}

    for role_dict in workgroup_dict_list:
        for value in role_dict.values():
            workgroup_dict.update({value: role_dict})

    return workgroup_dict


def make_objects_inactive(obj_ls):
    for obj in obj_ls:
        obj.status = "inactive"


workgroup_dict = make_workgroup_dict()


def get_smiles(ids):
    smiles = []
    for id_value in ids:
        if id_value.isdigit():
            smiles.append(str(select(c.smiles for c in db.Compound if c.id == id_value).first()))
        else:
            species_name = re.findall("\'.*\'", id_value)[0]
            species_name = species_name[1:]
            species_name = species_name[:-1]
            workbook_id = id_value.replace(species_name, "")
            workbook_id = re.findall("\d+", workbook_id)[0]
            smiles.append(str(select(c.smiles for c in db.NovelCompound if c.name == species_name and c.workbook.id ==
                                     workbook_id).first()))
    return smiles
