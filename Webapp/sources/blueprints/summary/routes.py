#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This module receives data from the reaction table
via POST request and renders the summary template
"""
import ast
import json

from flask import Response, abort, jsonify, render_template, request
from flask_login import login_required
from sources import auxiliary, services

from . import summary_bp


# Processing data from the reaction table and creating summary with H&S report
@summary_bp.route("/_summary", methods=["POST"])
def summary() -> Response:
    # must be logged in
    """This function receives the reaction information from browser, calculates
    green metrics, gives hazard information, and renders the summary"""
    if not (
        str(request.form["demo"]) == "demo" or str(request.form["tutorial"]) == "yes"
    ):
        # check user permission
        workgroup_name = str(request.form["workgroup"])
        workbook_name = str(request.form["workbook"])
        if not auxiliary.security_member_workgroup_workbook(
            workgroup_name, workbook_name
        ):
            abort(401)
    # check there is data to get and if so get it
    summary_table_data = str(request.form["js_summary_table_data"])
    if summary_table_data != "no data":
        summary_table_data = ast.literal_eval(summary_table_data)

    request_data = services.utils.update_dict_keys_to_snake_case(request.form)

    unit_data = services.summary.get_unit_data(request_data)
    reactant_data = services.summary.get_reactant_data(request_data)
    reagent_data = services.summary.get_reagent_data(request_data)
    solvent_data = services.summary.get_solvent_data(request_data)
    product_data = services.summary.get_product_data(request_data)

    # check all the requirement information has been typed into the reaction table
    check_results = services.summary.check_required_data_is_present(
        reactant_data, reagent_data, solvent_data, product_data
    )
    # if the check fails we return a message to inform the user they are missing data
    if check_results != "checks successful":
        return jsonify({"summary": check_results})

    sustainability_data = services.sustainability.SustainabilityMetrics(
        reactant_data, reagent_data, solvent_data, product_data
    ).get_sustainability_metrics()

    risk_data = services.summary.get_risk_data(
        reactant_data, reagent_data, solvent_data, product_data
    )

    # if product mass and reactant mass sum are calculated, then it forms a summary table
    if product_data and reactant_data:
        summary_data = {
            **unit_data,
            **reactant_data,
            **reagent_data,
            **solvent_data,
            **product_data,
            **sustainability_data,
            **risk_data,
        }
        summary_table = services.summary.render_summary_template(summary_data)
        return jsonify({"summary": summary_table})
    else:
        pass
    return jsonify(
        {"summary": "Ensure you have entered all the necessary information!"}
    )  # otherwise it shows this message


@summary_bp.route("/element_sustainability", methods=["POST", "GET"])
@login_required
def element_sustainability() -> Response:
    # must be logged in
    return render_template("element_sustainability.html")


@summary_bp.route("/pdf", methods=["POST", "GET"])
@login_required
def pdf():
    """
    Saves the autogenerated PDF for a reaction, overwriting the old one if present.
    """
    services.auth.reaction_files(permission_level="edit")
    new_upload = services.file_attachments.UploadExperimentDataFiles(
        request, autogenerated_file=True
    )
    new_upload.validate_files()
    new_upload.remove_duplicate_autogenerated_summaries()
    new_upload.remove_duplicate_autogenerated_summaries()
    new_upload.save_validated_files()
    return "", 204


@summary_bp.route("/get_file_attachment_list", methods=["POST"])
@login_required
def get_file_attachment_list():
    """
    Gets a list of file attachments for the current reaction identified from the request data
    """
    services.auth.reaction_files(permission_level="view")
    reaction = services.reaction.get_current_from_request()
    file_attachments = sorted(
        reaction.file_attachments, key=lambda x: not x.autogenerated
    )
    file_attachments_dict_list = [
        {"name": x.display_name, "uuid": x.uuid, "autogenerated": x.autogenerated}
        for x in file_attachments
    ]
    return jsonify({"file_attachments": file_attachments_dict_list})
