import base64
import hashlib
import io
import os
import uuid
from datetime import datetime
from typing import Optional

import magic
import pytz
from azure.core.exceptions import ResourceExistsError, ResourceNotFoundError
from azure.storage.blob import BlobClient, BlobServiceClient, ContainerClient
from flask import abort, current_app, request
from sources import db, models, services
from werkzeug.utils import secure_filename


def file_from_uuid(file_uuid: str) -> models.ReactionDataFile:
    """
    Return a database file object from the UUID (autogenerated unique identifier).

    Args:
        file_uuid (str): A string containing the UUID of the file.

    Returns:
        models.ReactionDataFile: An instance of the ReactionDataFile model representing the database file object.
    """
    return (
        db.session.query(models.ReactionDataFile)
        .filter(models.ReactionDataFile.uuid == file_uuid)
        .first()
    )


def get_blob_client(container_name: str, blob_name: str) -> BlobClient:
    """
    Gets the blob client for a specific blob
    Args:
        container_name - the name of the container the blob is saved in
        blob_name - the name of the blob
    Returns:
        The blob client of the specified blob
    """
    # connect to azure
    blob_service_client = services.file_attachments.connect_to_azure_blob_service()
    # make or get container
    services.file_attachments.create_or_get_existing_container_client(
        blob_service_client, container_name
    )
    # connect to the blob client
    return blob_service_client.get_blob_client(container=container_name, blob=blob_name)


def delete_file_attachment(request_source: str, file_uuid: str = None):
    """
    Delete file attached to reaction from storage and reference in database

    Args:
        request_source: "user" or "server" depending on the origin of the request
        file_uuid: A string containing the UUID of the file.
    """
    if not file_uuid:
        file_uuid = request.form["uuid"]
    # get file object and authenticate the current process
    file_object = services.file_attachments.database_object_from_uuid(file_uuid)
    services.auth.reaction_files(
        permission_level="edit",
        request_source=request_source,
        file_object_for_deletion=file_object,
    )
    # connect to blob to delete and then confirm this.
    blob_client = services.file_attachments.get_blob(file_uuid)
    delete_blob(blob_client)
    # update database to reflect these changes
    db.session.delete(file_object)
    db.session.commit()


def delete_blob(blob_client: BlobClient):
    """
    Tries to delete a blob, handles the error if the blob is not found but raises an error if the blob is not deleted

    Args: blob_client - the client for the blob being deleted
    """
    try:
        blob_client.delete_blob()
        if blob_client.exists():
            abort(401)
    except ResourceNotFoundError:
        pass


def sha256_sum_from_file_uuid(file_uuid: str) -> str:
    """
    Retrieves the SHA-256 hash value from Azure Blob Storage for the file associated with the provided UUID.

    Args:
        file_uuid: A string containing the UUID of the file.

    Returns:
        str: A string containing the hexadecimal representation of the SHA-256 hash.
    """
    blob_client = services.file_attachments.get_blob()
    stream_storage = blob_client.download_blob(uuid=file_uuid)
    file_content = stream_storage.readall()
    return sha256_from_file_contents(file_content)


def sha256_from_file_contents(file_content: bytes) -> str:
    """
    Calculates the SHA-256 hash value from the provided file content.

    Args:
        file_content: Bytes representing the content of the file.

    Returns:
        str: A string containing the hexadecimal representation of the SHA-256 hash.
    """
    sha256_hash = hashlib.sha256()
    sha256_hash.update(file_content)
    return sha256_hash.hexdigest()


def database_object_from_uuid(file_uuid: str) -> models.ReactionDataFile:
    """
    Return a database file object from the UUID (autogenerated unique identifier).

    Args:
        file_uuid (str): A string containing the UUID of the file.

    Returns:
        models.ReactionDataFile: An instance of the ReactionDataFile model representing the database file object.
    """
    return (
        db.session.query(models.ReactionDataFile)
        .filter(models.ReactionDataFile.uuid == file_uuid)
        .first()
    )


def get_blob(file_uuid: str = None) -> BlobClient:
    """
    Returns a binary large object (blob) from Azure Storage using the file UUID and container name.

    Args:
        file_uuid (str, optional): A string containing the UUID of the file. If not provided,
        it is extracted from the request form data.

    Returns:
        BlobClient: An instance of the Azure Blob Client representing the specified blob.
    """
    # connect to azure
    blob_service_client = connect_to_azure_blob_service()
    # connect to blob
    container_name = current_app.config["STORAGE_CONTAINER"]
    if file_uuid is None:
        file_uuid = request.form["uuid"]
    blob_client = blob_service_client.get_blob_client(
        container=container_name, blob=file_uuid
    )
    return blob_client


def connect_to_azure_blob_service() -> BlobServiceClient:
    """
    Returns the Azure blob service client using the connection string from configs.
    From this object, file attachment contents can be accessed by specifying the container name and file uuid.
    Returns:
        BlobServiceClient: An instance of the Azure Blob Service Client.
    """
    return BlobServiceClient.from_connection_string(
        current_app.config["AZURE_STORAGE_CONNECTION_STRING"]
    )


def create_or_get_existing_container_client(
    blob_service_client: BlobServiceClient, container_name: str
) -> ContainerClient:
    """
    Creates or gets the container client from its name.
    Args:
        blob_service_client - the blob service client used to connect to azure blob service
        container_name - the name of the container client being returned
    Returns:
        The container client for the specified container
    """
    try:
        container_client = blob_service_client.create_container(container_name)
    except ResourceExistsError:
        container_client = blob_service_client.get_container_client(container_name)
    return container_client


def download_from_blob_client(blob_client: BlobClient, file_uuid: str) -> str:
    """
    Downloads file contents from a BlobClient and verifies integrity based on a provided file UUID.

    Args:
        blob_client: The BlobClient representing the Azure Blob Storage blob.
        file_uuid: A string containing the UUID of the file for integrity verification.

    Returns:
        str: A base64-encoded string representing the file contents after integrity verification.
    """
    stream = blob_client.download_blob()
    file_contents = stream.readall()
    verify_integrity(file_contents, file_uuid)
    file_attachment = base64.b64encode(file_contents).decode()
    return file_attachment


def verify_integrity(file_contents: bytes, file_uuid: str):
    """
    Verifies the integrity of file contents by comparing the SHA-256 checksum with the stored checksum
    in the database for the file associated with the provided UUID.

    Args:
        file_contents: Bytes representing the content of the file.
        file_uuid: A string containing the UUID of the file for integrity verification.

    Raises:
        HTTPException: Raised with a status code of 400 if the integrity check fails.
    """
    file_db_object = database_object_from_uuid(file_uuid)
    if (
        file_db_object.sha256_checksum != "not_available"
    ):  # older files use this default value
        checksum = services.file_attachments.sha256_from_file_contents(file_contents)
        if file_db_object.sha256_checksum != checksum:
            print("invalid checksum. could not verify file integrity")
            abort(400)


class UploadExperimentDataFiles:
    def __init__(self, ajax_request, autogenerated_file=False):
        self.files_to_upload = ajax_request.files
        self.institution = db.session.query(models.Institution).first()
        self.workgroup = ajax_request.form["workgroup"]
        self.workbook = ajax_request.form["workbook"]
        self.reaction_id = ajax_request.form["reactionID"]
        self.validated_files = []
        self.container_client = None
        self.reaction = services.reaction.get_current_from_request()
        self.uploaded_files = []
        self.file_hash = ""
        self.autogenerated = autogenerated_file

    def validate_number_of_attachments(self):
        number_of_attachments = len(self.reaction.file_attachments)
        if number_of_attachments >= 10:
            abort(401)

    def validate_files(self):
        for file in self.files_to_upload.values():
            validation_result = self.file_security_validation(file)
            if validation_result == "success":
                self.validated_files.append(file)
            else:
                abort(401)

    def save_validated_files(self):
        for file in self.validated_files:
            # give the filename is a unique identifier and file.filename is the user supplied identifier they see
            filename = str(uuid.uuid4())
            self.save_blob(file, filename)
            self.save_file_details_to_database(file, filename)
            self.uploaded_files.append(
                {
                    "uuid": filename,
                    "name": file.filename,
                    "autogenerated": self.autogenerated,
                }
            )

    def save_file_details_to_database(self, file, filename):
        current_time = datetime.now(pytz.timezone("Europe/London")).replace(tzinfo=None)
        storage_name = self.container_client.account_name
        container_name = self.container_client.container_name
        file_size = os.fstat(file.fileno()).st_size
        file_ext = os.path.splitext(file.filename)[1]
        file_details = {
            "mimetype": file.mimetype,
            "size": file_size,
            "extension": file_ext,
        }
        models.ReactionDataFile.create(
            reaction=self.reaction.id,
            storage_name=storage_name,
            container_name=container_name,
            uuid=filename,
            display_name=file.filename,
            time_of_upload=current_time,
            file_details=file_details,
            sha256_checksum=self.file_hash,
            autogenerated=self.autogenerated,
        )

    def save_blob(self, file, filename):
        # connect to storage account
        blob_service_client = services.file_attachments.connect_to_azure_blob_service()
        # connect to container
        container_name = current_app.config["STORAGE_CONTAINER"]
        self.container_client = create_or_get_existing_container_client(
            blob_service_client, container_name
        )
        blob_client = blob_service_client.get_blob_client(
            container=container_name, blob=filename
        )
        print("uploading blob")
        file.stream.seek(0)
        self.file_hash = services.file_attachments.sha256_from_file_contents(
            file.stream.read()
        )
        if not self.file_hash:
            print("Failed to generate hash")
            abort(500)
        # Upload the blob data - default blob type is BlockBlob
        file.stream.seek(0)
        in_memory_file = io.BytesIO(file.stream.read())
        blob_client.upload_blob(in_memory_file, blob_type="BlockBlob")
        # confirm upload
        if not blob_client.exists():
            print(f"blob {filename} upload failed")
            abort(401)

    @staticmethod
    def file_security_validation(file):
        """Validates the filesize, name, extension, and mimetype"""
        filename = file.filename
        secure_filename(filename)
        if filename != "":
            # size under 1 mb
            filesize = os.fstat(file.fileno()).st_size
            if filesize > 1000000:
                print("file too large")
                return "failure"
            # acceptable file extension
            file_ext = os.path.splitext(filename)[1]
            if file_ext not in current_app.config["UPLOAD_EXTENSIONS"]:
                print("incorrect extension")
                return "failure"
            # acceptable mimetype
            mime = magic.Magic(mime=True)
            mime_type = mime.from_buffer(file.read(2048))
            if mime_type not in current_app.config["UPLOAD_MIME_TYPES"]:
                print("incorrect mimetype")
                return "failure"
        else:
            return "failure"
        return "success"

    def remove_duplicate_autogenerated_summaries(self):
        """Removes duplicate autogenerated summaries"""
        # load all file attachments for current reaction into a list
        file_attachments = self.reaction.file_attachments
        # iterate through the list to delete any autogenerated. Should only be one.
        for file in file_attachments:
            if file.autogenerated:
                # delete this file and replace with new one
                services.file_attachments.delete_file_attachment(
                    request_source="server", file_uuid=file.uuid
                )


def get_autogenerated_blob_uuid(reaction_id: int) -> Optional[str]:
    """Returns the uuid for the autogenerated pdf blob of a reaction"""
    reaction_data_file = (
        db.session.query(models.ReactionDataFile)
        .filter(models.ReactionDataFile.reaction == reaction_id)
        .filter(models.ReactionDataFile.autogenerated)
        .first()
    )
    if reaction_data_file:
        return reaction_data_file.uuid
