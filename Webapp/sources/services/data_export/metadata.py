import json
from typing import Dict, List, Optional

from sources import models, services

from . import utils


class ReactionMetaData:
    """
    Takes a reaction object from the database and makes a dictionary for metadata to describe the reaction
    For consistency, all missing or default values are standardised to equal None.
    """

    amount_factor_dict = {"ug": 0.000001, "mg": 0.001, "g": 1}
    mass_factor_dict = {"umol": 0.000001, "mmol": 0.001, "mol": 1}
    none_dict = {"-select-": None}

    def __init__(self, db_reaction: models.Reaction):
        """
        Creates an instance of the ReactionMetaData class.
        Sets up variables for creating the metadata and calls the function to create the metadata dictionary.


        Args:
            db_reaction is the reaction we are generating metadata for
        """
        self.db_reaction = db_reaction
        self.rxn_data = json.loads(db_reaction.reaction_table_data)
        self.summary_data = json.loads(db_reaction.summary_table_data)
        # blank dictionary if 'to_export' is not present or convert the 'to_export' to standard dict if it is present
        self.exported_from_js = (
            self._list_to_dict(json.loads(self.summary_data["to_export"]))
            if self.summary_data.get("to_export")
            else {}
        )
        self.metadata_access_methods = self._get_metadata_access_methods()
        self.units = {}
        self.metadata_dict = {}
        self._make_metadata_dict()

    def _make_metadata_dict(self):
        """Called on __init__, makes the metadata dictionary by iterating through the access method dict"""
        self._initialise_units()
        for key, access_method in self.metadata_access_methods.items():
            self.metadata_dict.update({key: access_method()})

    def get_dict(self) -> Dict:
        """Returns the reaction's metadata as a dictionary"""
        return self.metadata_dict

    # 'who' did the reaction

    def _read_creator_username(self) -> str:
        """Returns the username of the reaction creator"""
        return self.db_reaction.creator_person.user.username

    def _read_workbook(self) -> str:
        """Returns the name of the workbook the reaction was made in"""
        return self.db_reaction.workbook.name

    def _read_workgroup(self) -> str:
        """Returns the name of the workgroup the reaction was made in"""
        return self.db_reaction.workbook.WorkGroup.name

    # 'when' was the reaction done

    def _read_time_of_creation(self) -> str:
        """Returns the time the reaction was made"""
        return self.db_reaction.time_of_creation.isoformat()

    def _read_time_of_last_update(self) -> str:
        """Returns the time the most recent update to the reaction was made"""
        return self.db_reaction.time_of_update.isoformat()

    def _read_reaction_completed(self) -> str:
        """Returns whether the reaction is 'complete' or 'not complete'"""
        return self.db_reaction.complete

    # what was the reaction
    def _read_reaction_name(self) -> str:
        """Returns the user created reaction name"""
        return self.db_reaction.name

    def _read_reaction_id(self) -> str:
        """Returns the autogenerated reaction id. e.g., RXN-001"""
        return self.db_reaction.reaction_id

    def _read_solvents(self) -> Optional[List[Dict]]:
        """
        If solvents are present, returns a list of dictionaries with the solvent name, SMILES, volume and volume unit
        """
        if not services.data_export.utils.check_compounds_present(
            self.db_reaction, "solvent"
        ):
            return None

        solvent_data = self._get_compound_data("solvent")
        self._standardise_compound_data(solvent_data)
        number_of_solvents = len(solvent_data["names"])
        solvent_data.update(
            {
                "volume_unit": number_of_solvents * [self.units["solvent_volume"]],
            }
        )
        return self._format_solvent_data(solvent_data)

    def _read_reactants(self) -> Optional[List[Dict]]:
        """
        If reactants are present, returns a list of dictionaries with reactant name, SMILES, masses, amounts and units
        """
        if not services.data_export.utils.check_compounds_present(
            self.db_reaction, "reactants"
        ):
            return None

        reactant_data = self._get_compound_data("reactant")
        self._standardise_compound_data(reactant_data)
        number_of_reactants = len(reactant_data["names"])
        reactant_data.update(
            {
                "mass_unit": number_of_reactants * [self.units["reactant_mass"]],
                "amount_unit": number_of_reactants * [self.units["reactant_amount"]],
            }
        )
        return self._format_compound_data(reactant_data)

    def _read_reagents(self) -> Optional[List[Dict]]:
        """
        If reagents are present, returns a list of dictionaries with reagent name, SMILES, masses, amounts, and units
        """
        if not services.data_export.utils.check_compounds_present(
            self.db_reaction, "reagents"
        ):
            return None
        reagent_data = self._get_compound_data("reagent")
        self._standardise_compound_data(reagent_data)
        number_of_reagents = len(reagent_data["names"])
        reagent_data.update(
            {
                "mass_unit": number_of_reagents * [self.units["reactant_mass"]],
                "amount_unit": number_of_reagents * [self.units["reactant_amount"]],
            }
        )
        return self._format_compound_data(reagent_data)

    def _read_products(self) -> Optional[List[Dict]]:
        """
        If products are present, returns a list of dictionaries with product name, SMILES, masses, amounts, and units
        """
        if not services.data_export.utils.check_compounds_present(
            self.db_reaction, "products"
        ):
            return None
        product_data = self._get_compound_data("product")
        self._standardise_compound_data(product_data)
        number_of_products = len(product_data["names"])
        product_data.update(
            {
                "mass_unit": number_of_products * [self.units["product_mass"]],
                "amount_unit": number_of_products * [self.units["product_amount"]],
            }
        )
        return self._format_compound_data(product_data)

    def _read_experimental_writeup(self) -> str:
        """Returns the experimental writeup, currently overlaps with the description."""
        description = self.db_reaction.description
        return description if description != "" else None

    def _read_standard_protocols_used(self) -> Optional[List[str]]:
        """Returns a list of the standard protocol fields that the user ticked that apply to this reaction"""
        standard_protocols = [
            utils.ReactionStringMapper.radio_buttons(
                services.utils.camelCase_to_snake_case(x)
            )
            for x in self.summary_data.get("radio_buttons")
            if x is not None
        ]
        return standard_protocols if standard_protocols != [] else None

    def _read_file_attachment_names(self) -> Optional[List[str]]:
        """Returns a list of the names for the file attachments for this reaction"""
        file_names = [x.display_name for x in self.db_reaction.file_attachments]
        return file_names if file_names != [] else None

    def _read_addenda(self) -> Optional[List[Dict]]:
        """Returns the addenda a list of dictionaries with the author, comment text, and date."""
        return (
            [x.to_export_dict() for x in self.db_reaction.addenda]
            if self.db_reaction.addenda
            else None
        )

    # how sustainable was the reaction
    def _read_solvent_sustainability(self) -> Optional[List[str]]:
        """Returns a list of strings to describe the sustainability of each solvent using the CHEM21 system"""
        cleaned_solvent_primary_keys = utils.remove_default_data(
            self.db_reaction.solvent
        )
        sustainability_flags = [
            utils.ReactionStringMapper.solvent_sustainability(
                services.solvent.sustainability_from_primary_key(x)
            )
            for x in cleaned_solvent_primary_keys
        ]
        return sustainability_flags if sustainability_flags != [] else None

    def _read_reaction_safety(self) -> Optional[str]:
        """
        Returns a string to for overall risk of the reaction according to the hazard/exposure/risk matrix.
        L-low, M-Medium, H-High, VH-Very High
        """
        return self.exported_from_js.get("Overall-Risk-Rating")

    def _read_temperature(self) -> Optional[str]:
        """Returns the reaction temperature the user entered into the summary table"""
        temperature = self.summary_data.get("reaction_temperature")
        return temperature if temperature != "" else None

    def _read_element_sustainability(self) -> Optional[str]:
        """Returns the element sustainability expressed as a range of years"""
        return utils.ReactionStringMapper.element_sustainability(
            self.summary_data.get("element_sustainability")
        )

    def _read_batch_or_flow(self) -> Optional[str]:
        """Returns 'batch' or 'flow' from the user completed dropdown in the summary table"""
        batch_flow = self.summary_data.get("batch_flow")
        return batch_flow if batch_flow != "-select-" else None

    def _read_isolation_method(self) -> Optional[str]:
        """Returns the method of purification used from the dropdown the user selected in the summary table"""
        isolation_method = utils.ReactionStringMapper.isolation(
            self.summary_data.get("isolation_method")
        )
        return isolation_method if isolation_method else None

    def _read_stoichiometry(self) -> Optional[str]:
        """Returns string to indicate whether catalyst was used or stoichiometric reagents or neither"""
        stoich = self.summary_data.get("catalyst_used")
        return stoich if stoich != "-select-" else None

    def _read_catalyst_recovery(self) -> Optional[str]:
        """Returns string to indicate, if a catalyst was used, was it recovered."""
        cat_recovery = self.summary_data.get("catalyst_recovered")
        return cat_recovery if cat_recovery != "-select-" else None

    def _read_atom_economy(self) -> Optional[str]:
        """
        Returns the atom economy as a string - percentage of mass of starting atoms in desired product
        Based on the theoretical yield hence does not require actual yield data
        """
        return (
            self.exported_from_js.get("Atom Efficiency")
            if self.exported_from_js.get("Atom Efficiency")
            else None
        )

    def _read_mass_efficiency(self) -> str:
        """
        Returns the mass efficiency as a string - percentage of mass of starting atoms in desired product.
        Based on the real yield - does require user entered mass yield
        """
        return (
            self.summary_data.get("mass_efficiency")
            if self.summary_data.get("mass_efficiency")
            else None
        )

    def _read_percent_yield(self) -> Optional[str]:
        """
        Returns the percentage yield for the reaction if the user has entered the product mass they obtained

        Returns:
              percentage yield as a string
        """
        actual_mass_yield = self.summary_data.get("real_product_mass")
        if not actual_mass_yield:
            return None
        return str(
            services.sustainability.percent_yield_from_rxn_data(
                self.rxn_data, float(actual_mass_yield)
            )
        )

    def _read_conversion(self) -> Optional[str]:
        """Returns the conversion from the metrics if present else None"""
        return (
            self.summary_data.get("conversion")
            if self.summary_data.get("conversion")
            else None
        )

    def _read_selectivity(self) -> Optional[str]:
        """Returns the selectivity from the metrics if present else None"""
        return (
            self.summary_data.get("selectivity")
            if self.summary_data.get("conversion")
            else None
        )

    def _read_sustainability_flags(self) -> Dict:
        """Returns a dictionary with a colour-coded flag for each metric. Green, amber, red or None"""
        return {
            "temperature_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Temperature Sustainability")
            ),
            "element_sustainability_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Elements Sustainability")
            ),
            "batch_or_flow_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Batch or Flow Sustainability")
            ),
            "isolation_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Isolation Sustainability")
            ),
            "catalyst_used_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Catalyst Sustainability")
            ),
            "catalyst_recovery_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Recovery Sustainability")
            ),
            "atom_economy_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Atom Economy Sustainability")
            ),
            "mass_efficiency_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Mass Efficiency Sustainability")
            ),
            "yield_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Yield Sustainability")
            ),
            "conversion_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Conversion Sustainability")
            ),
            "selectivity_flag": utils.ReactionStringMapper.css_classes_to_chem21_colour_flag(
                self.exported_from_js.get("Selectivity Sustainability")
            ),
        }

    def _initialise_units(self):
        """Updates the units dictionary with all units used in the reaction."""
        self.units["reactant_mass"] = self.rxn_data["mass_units"]
        self.units["reactant_amount"] = self.rxn_data["amount_units"]
        self.units["product_amount"] = self.rxn_data["product_amount_units"]
        self.units["product_mass"] = self.rxn_data["product_mass_units"]
        self.units["solvent_volume"] = self.rxn_data["solvent_volume_units"]

    @staticmethod
    def _standardise_compound_data(compound_data: Dict):
        """
        Sometimes it is possible for an empty string or other erroneous variables to enter the json
        In this function we trim the length of lists in the dictionary so all are equal to the shortest one
        """
        length_of_values = []
        for value in compound_data:
            length_of_values.append(len(value))

        length_of_values = [len(x) for x in compound_data.values()]
        if min(length_of_values) == max(length_of_values):
            return
        # if there are lists which are longer than others then we trim the list to be of the same length
        min_length = min(length_of_values)
        for key, value in compound_data.items():
            if len(value) > min_length:
                compound_data[key] = value[:min_length]

    @staticmethod
    def _format_compound_data(compound_data: Dict) -> List[Dict]:
        """
        Formats compound data from a dictionary containing lists into a list of dictionaries. Not for solvents

        Args:
            compound_data - dict with all the values of equal length for compound data
        Returns:
             A list of dictionaries, 1 per compound for a specific reaction component.
        """

        return [
            {
                "name": name,
                "SMILES": smiles,
                "amount": amount,
                "mass": mass,
                "amount_unit": amount_unit,
                "mass_unit": mass_unit,
                "h_codes": h_code,
                "physical_form": physical_form,
            }
            for name, smiles, amount, mass, amount_unit, mass_unit, h_code, physical_form in zip(
                compound_data["names"],
                compound_data["smiles"],
                compound_data["amounts"],
                compound_data["masses"],
                compound_data["amount_unit"],
                compound_data["mass_unit"],
                compound_data["h_codes"],
                compound_data["physical_forms"],
            )
        ]

    @staticmethod
    def _format_solvent_data(solvent_data: Dict) -> List[Dict]:
        """
        Formats solvent data from a dictionary containing lists into a list of dictionaries. Only for solvents

        Args:
            solvent_data - dict with all the values of equal length for solvent data
        Returns:
             A list of dictionaries, 1 per solvent.
        """
        return [
            {
                "name": name,
                "SMILES": smiles,
                "volume": volume,
                "volume_unit": volume_unit,
                "physical_form": physical_form,
                "hazard_codes": h_code,
            }
            for name, smiles, volume, volume_unit, physical_form, h_code in zip(
                solvent_data["names"],
                solvent_data["smiles"],
                solvent_data["volumes"],
                solvent_data["volume_unit"],
                solvent_data["physical_forms"],
                solvent_data["h_codes"],
            )
        ]

    def _get_compound_data(self, component: str) -> Dict:
        """
        For a component reagent/solvent/reactant/product we make a dictionary with the required data
        Args:
            component - indicate what reaction role we are making the dict for (e.g., reactant)
        Returns:
            A dictionary with compound data

        """
        compound_dict = {
            "names": self._get_compound_names(component),
            "h_codes": self._get_h_codes(component),
            "physical_forms": self._get_physical_forms(component),
        }
        if component == "solvent":
            compound_dict["volumes"] = self._get_volumes(component)
            compound_dict["smiles"] = services.all_compounds.get_smiles_list(
                self.db_reaction.solvent, person=self.db_reaction.creator_person
            )
        else:  # for reactants/reagents/products
            compound_dict["smiles"] = self._get_compound_smiles(
                component + "s"
            )  # plural used in models.reaction.components
            compound_dict["masses"] = self._get_masses(component)
            compound_dict["amounts"] = self._get_amounts(component)
        return compound_dict

    def _get_compound_names(self, component: str) -> List[str]:
        """Returns a list of compound names for type of component: reactant/reagent/solvent/product"""
        return [x for x in self.rxn_data[f"{component}_names"]]

    def _get_compound_smiles(self, component: str) -> List[str]:
        """Returns a list of SMILES for type of component: reactant/reagent/product. Not for Solvents"""
        return getattr(self.db_reaction, component)

    def _get_amounts(self, component: str) -> List[str]:
        """Returns a list of amounts for type of component: reactant/reagent/solvent/product"""
        return [
            str(round(float(x), 2)) for x in self.rxn_data[f"{component}_amounts_raw"]
        ]

    def _get_masses(self, component: str) -> List[str]:
        """Returns a list of masses for type of component: reactant/reagent/solvent/product"""
        return [
            str(round(float(x), 2)) for x in self.rxn_data[f"{component}_masses_raw"]
        ]

    def _get_volumes(self, component) -> List[str]:
        """Returns a list of volumes for type of component: reactant/reagent/solvent/product"""
        return [
            str(round(float(x), 2)) if x else None
            for x in self.rxn_data[f"{component}_volumes"]
        ]

    def _get_h_codes(self, component) -> List[str]:
        """Returns a list of GHS hazard codes for type of component: reactant/reagent/solvent/product"""
        return [x for x in self.rxn_data[f"{component}_hazards"]]

    def _get_physical_forms(self, component):
        """Returns a list of physical forms for type of component: reactant/reagent/solvent/product"""
        return [
            utils.ReactionStringMapper.physical_forms(x)
            for x in self.rxn_data[f"{component}_physical_forms"]
        ]

    def _get_metadata_access_methods(self) -> Dict:
        """Returns a dictionary with the key and the associated access function used to get the value"""
        return {
            # who
            "creator_username": self._read_creator_username,
            "creator_workbook": self._read_workbook,
            "creator_workgroup": self._read_workgroup,
            # when
            "time_of_creation": self._read_time_of_creation,
            "time_of_last_update": self._read_time_of_last_update,
            "reaction_completed": self._read_reaction_completed,
            # what
            "reaction_id": self._read_reaction_id,
            "reaction_name": self._read_reaction_name,
            "reagents": self._read_reagents,
            "reactants": self._read_reactants,
            "solvents": self._read_solvents,
            "products": self._read_products,
            "experimental_writeup": self._read_experimental_writeup,
            "standard_protocols_used": self._read_standard_protocols_used,
            "file_attachment_names": self._read_file_attachment_names,
            "addenda": self._read_addenda,
            # sustainability
            "solvent_sustainability": self._read_solvent_sustainability,
            "safety": self._read_reaction_safety,
            "temperature": self._read_temperature,
            "element_sustainability": self._read_element_sustainability,
            "batch_or_flow": self._read_batch_or_flow,
            "isolation_method": self._read_isolation_method,
            "catalyst_use": self._read_stoichiometry,
            "catalyst_recovery": self._read_catalyst_recovery,
            "atom_economy": self._read_atom_economy,
            "mass_efficiency": self._read_mass_efficiency,
            "percent_yield": self._read_percent_yield,
            "conversion": self._read_conversion,
            "selectivity": self._read_selectivity,
            "sustainability_data": self._read_sustainability_flags,
        }

    @staticmethod
    def _list_to_dict(ls: List[Dict]) -> Dict:
        """From [{'key': 'risk-score', 'value': 'danger'}] -> {'risk-score': 'danger'}"""
        result_dict = {}
        for item in ls:
            try:
                result_dict[item["key"]] = item["value"]
            except KeyError:
                result_dict[item["key"]] = None
        return result_dict
